/*
时间限制：
	1s。
空间限制：
	512m。
题目：
	J - 最近的医院。
描述：
	林寻走出门，看见阮芷站在门外，顶着那个诡异，不现实的蓝色方形。他：“！”——东君全程正常，头顶没有这个蓝色东西，让他以为自己的幻觉已经好了。他回头看东君。东君头顶什么都没有，甚至因他的回头，微微笑了一下。
	东君是个美人，很冷的那种，眼中含了些微笑意后，整个人更加好看。但美色并不能阻止林浔浑身发毛，他惊疑不定地望回阮芷的头顶，然后和东君告别，被领着进入电梯，下楼。
	电梯门开，林浔震惊地睁大了眼睛。一楼大厅来来往往的人，头顶全部顶着那个半透明蓝色东西，他一度觉得自己进入了另一个次元。阮芷顶着那个鬼方块，送他到了银河大厦外。这里地段繁华，路上行人川流不息，而每个人头上都有一块蓝色东西在诡异地幽幽悬浮着，几乎要汇聚成一个蓝色的河流。

	一辆车朝这边驶来，是洛神公司唯一的固定资产——一辆二手捷达。上了车，王安全头上也漂着一块那东西。王安全摇晃他的肩膀：“兄弟？怎么样？”
	林浔：“我见到了东君。”
	“啊哈！”副驾驶位的赵架构欢呼一声：“三千万！”然后道：“回家！我们去庆祝！”基于“洛神”的自动驾驶系统启动，二手捷达掉头回去。
	“不，不是三千万，”林浔道：“他打算用二十万，买我们部分股权。”
	过了一会儿，王安全愣愣掰着手指头：“一二三四五……少零了？”他狠狠一拍林浔的肩膀：“这不对啊！”
	林浔：“是有点，我现在很嫉妒 Lions。”
	“假如，我是说假如，你是东君，你是银河的老大。你很有钱，不管什么排行榜都在前三，而且你的投资还很多，任何一个行业都有。你的时间是不是很宝贵？”王安全问。
	林浔：“宝贵。”
	“然后，你花了宝贵的一个下午，和一个没名没姓的程序员谈了一桩二十万的生意，最后还没彻底谈成，还说让他考虑？”王安全盯着他：“就二十万！对东君来说，这算钱么？哪怕是三千万，对他来说，那也不算钱啊。”
	“首先我不是没名没姓的程序员，我的水平并不低。”林浔面无表情：“其次你完全把东君看成了一个商人，事实上他不是。他和我们一样，也写代码，还懂数学。他只是看到了感兴趣的代码，然后想和我交流一下其中的算法。”
	“不是，你被他蛊惑了，你们脑残粉都是这样——”

	林浔没有理他，道：“别说话。”他扒着王安全的肩膀，在狭窄的空间里近距离观看那个蓝色东西。起初是模糊的，后来随着他的注视，渐渐变清楚了很多。半透明，蓝色的，手指可以直接穿过去，像个二维投影，这界面竟有一丝丝熟悉。
	不对，不全是蓝色，上面有一个灰色的菜单栏，还写着单词。File, Edit …… Debug！林浔愣住了。“我……”他差一点脱口而出不文明用语。天知道，这是程序编译界面啊！C 语言的！还是最简陋的 Turbo C！
	
	这是什么魔幻场景？为什么每个人的头顶上都有一个 C 语言输入界面？林浔刹那间精神恍惚。
	王安全也精神恍惚：“所以你就打算答应二十万？二十？”他扑上去，看上去要质问林浔。
	“别闹。”林浔整个人都很不好，道：“改变路线。”
	自动驾驶程序“滴”了一声，缓缓停下。
	王安全：“去哪？”
	林浔：“最近的医院。”
	王安全：“……啊？”
	林浔喊了自动驾驶程序的名字：“洛，寻找最短路径。”
	“收到，x 市内有 n 个路口，从 1 到 n 编号中。编号完成。现在，我们位于 1 号路口，将前往位于 n 号路口的 yy 医院。寻找最短路径中……”
	已知 x 市内有 m 条道路，每条道路连接着两个路口，不存在两条道路连接相同的路口，道路均为双行道，林浔的汽车只能沿道路行驶。
输入：
	输入包含多行。
	第一行为两个非负整数 n、m，n 表示 x 市内路口的数量，路口由 1 到 n 编号，m 表示 x 市内连接路口的道路数量。
	接下来 m 行，每行包含三个正整数，u、v、z，u、v 均为 x 市内路口编号，表示 u 号路口与 v 号路口之间有一条长度为 z 的道路相连。
	保证 0 <= m，n <= 1e5，1 <= u、v <= n，u  != v，0 <= z <= 1e5。
输出：
	输出包含一行，为一个非负整数，表示林浔现在的位置到医院最短路径的长度。
样例：
	input:
		2 1
		1 2 1000
	output:
  		1000
*/

#include <iostream>
#include <queue>
#include <cstring>
#include <unordered_map>
using namespace std;

#define ll long long
#define INF 0x3f3f3f3f3f3f3f3f

ll dis[100010];
unordered_map <int, vector <pair <int, int>>> map;
//map[node] <to, val>

struct Node { ll num, dis; };
bool operator < (const Node &i, const Node &j) 
{ return i.dis > j.dis; }

void dijkstra(int start)
{
	dis[start] = 0;
	priority_queue <Node> q;
	q.push((Node){start, 0});
	while (! q.empty())
	{
		Node node = q.top(); q.pop();
		ll u = node.num, d = node.dis;
		if (dis[u] < d) continue;
		for (auto i: map[u])
		{
			ll v = i.first, w = i.second;
			if (dis[v] > dis[u] + w)
			{
				dis[v] = dis[u] + w;
				q.push((Node){v, dis[v]});
			}
		}
	}
}

int main()
{
	int n, m;
	scanf("%d%d", &n, &m);
	for (int i=1; i<=n; i++) dis[i] = INF;
	for (int i=1; i<=m; i++)
	{
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		map[u].push_back(make_pair(v, w));
		map[v].push_back(make_pair(u, w));
	}
	dijkstra(1);
	printf("%lld\n", dis[n]);
	return 0;
}
